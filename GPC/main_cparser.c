/* 
 * GPC - Gwinn Pascal Compiler
 * Main entry point using cparser
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser.h"
#include "combinators.h"
#include "pascal_parser.h"
#include "pascal_declaration.h"

// External ast_nil (defined in parser.c)
extern ast_t* ast_nil;

void print_usage(const char* prog_name) {
    fprintf(stderr, "Usage: %s <input.p> <output.s>\n", prog_name);
    fprintf(stderr, "  Compiles Pascal source to x86-64 assembly\n");
}

int main(int argc, char** argv) {
    if (argc < 3) {
        print_usage(argv[0]);
        return 1;
    }

    const char* input_file = argv[1];
    const char* output_file = argv[2];

    // Read input file
    FILE* file = fopen(input_file, "r");
    if (!file) {
        fprintf(stderr, "Error: Cannot open input file '%s'\n", input_file);
        return 1;
    }

    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);

    char* file_content = malloc(file_size + 1);
    if (!file_content) {
        fprintf(stderr, "Error: Memory allocation failed\n");
        fclose(file);
        return 1;
    }

    size_t bytes_read = fread(file_content, 1, file_size, file);
    file_content[bytes_read] = '\0';
    fclose(file);

    // Initialize parser
    combinator_t* parser = new_combinator();
    init_pascal_complete_program_parser(&parser);

    input_t* in = new_input();
    in->buffer = file_content;
    in->length = bytes_read;

    // Initialize ast_nil (already defined in parser.c, just needs to be set)
    if (ast_nil == NULL) {
        ast_nil = new_ast();
        ast_nil->typ = PASCAL_T_NONE;
    }

    // Parse
    fprintf(stderr, "Parsing %s...\n", input_file);
    ParseResult result = parse(in, parser);

    if (!result.is_success) {
        fprintf(stderr, "Parse error:\n");
        if (result.value.error) {
            fprintf(stderr, "  Line %d, Column %d: %s\n",
                    result.value.error->line,
                    result.value.error->col,
                    result.value.error->message);
            if (result.value.error->unexpected) {
                fprintf(stderr, "  Unexpected: %s\n", result.value.error->unexpected);
            }
            free_error(result.value.error);
        }
        free(file_content);
        free(in);
        free_combinator(parser);
        free_ast(ast_nil);
        return 1;
    }

    if (in->start < in->length) {
        fprintf(stderr, "Warning: Parser did not consume entire input (at position %d of %d)\n",
                in->start, in->length);
    }

    fprintf(stderr, "Parsing successful!\n");
    
    // TODO: Implement semantic checking
    fprintf(stderr, "Semantic checking not yet implemented\n");
    
    // TODO: Implement code generation
    fprintf(stderr, "Code generation not yet implemented\n");
    
    // For now, just write a placeholder output
    FILE* out = fopen(output_file, "w");
    if (!out) {
        fprintf(stderr, "Error: Cannot open output file '%s'\n", output_file);
        free_ast(result.value.ast);
        free(file_content);
        free(in);
        free_combinator(parser);
        free_ast(ast_nil);
        return 1;
    }
    
    fprintf(out, "# Generated by GPC with cparser\n");
    fprintf(out, "# TODO: Implement code generation\n");
    fclose(out);

    // Cleanup
    free_ast(result.value.ast);
    free(file_content);
    free(in);
    free_combinator(parser);
    free_ast(ast_nil);

    fprintf(stderr, "Output written to %s\n", output_file);
    return 0;
}
