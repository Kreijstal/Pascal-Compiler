// === Procedure/Function Declaration Tests ===

void test_pascal_simple_procedure(void) {
    combinator_t* p = new_combinator();
    init_pascal_procedure_parser(&p);

    input_t* input = new_input();
    input->buffer = strdup("procedure MyProcedure; begin end");
    input->length = strlen(input->buffer);

    ParseResult res = parse(input, p);

    TEST_ASSERT(res.is_success);
    TEST_ASSERT(res.value.ast->typ == PASCAL_T_PROCEDURE_DECL);
    
    // Check procedure name
    ast_t* proc_name = res.value.ast->child;
    TEST_ASSERT(proc_name->typ == PASCAL_T_IDENTIFIER);
    TEST_ASSERT(strcmp(proc_name->sym->name, "MyProcedure") == 0);

    free_ast(res.value.ast);    free(input->buffer);
    free(input);
}

void test_pascal_procedure_with_params(void) {
    combinator_t* p = new_combinator();
    init_pascal_procedure_parser(&p);

    input_t* input = new_input();
    input->buffer = strdup("procedure MyProcedure(x: integer; y: string); begin end");
    input->length = strlen(input->buffer);

    ParseResult res = parse(input, p);

    TEST_ASSERT(res.is_success);
    TEST_ASSERT(res.value.ast->typ == PASCAL_T_PROCEDURE_DECL);
    
    // Check procedure name
    ast_t* proc_name = res.value.ast->child;
    TEST_ASSERT(proc_name->typ == PASCAL_T_IDENTIFIER);
    TEST_ASSERT(strcmp(proc_name->sym->name, "MyProcedure") == 0);
    
    // Check parameters exist
    ast_t* params = proc_name->next;
    TEST_ASSERT(params != NULL); // parameter list should exist

    free_ast(res.value.ast);    free(input->buffer);
    free(input);
}

void test_pascal_simple_function(void) {
    combinator_t* p = new_combinator();
    init_pascal_procedure_parser(&p);

    input_t* input = new_input();
    input->buffer = strdup("function Square(x: integer): integer; begin end");
    input->length = strlen(input->buffer);

    ParseResult res = parse(input, p);

    TEST_ASSERT(res.is_success);
    TEST_ASSERT(res.value.ast->typ == PASCAL_T_FUNCTION_DECL);
    
    // Check function name
    ast_t* func_name = res.value.ast->child;
    TEST_ASSERT(func_name->typ == PASCAL_T_IDENTIFIER);
    TEST_ASSERT(strcmp(func_name->sym->name, "Square") == 0);

    free_ast(res.value.ast);    free(input->buffer);
    free(input);
}

void test_pascal_function_no_params(void) {
    combinator_t* p = new_combinator();
    init_pascal_procedure_parser(&p);

    input_t* input = new_input();
    input->buffer = strdup("function GetValue: integer; begin end");
    input->length = strlen(input->buffer);

    ParseResult res = parse(input, p);

    TEST_ASSERT(res.is_success);
    TEST_ASSERT(res.value.ast->typ == PASCAL_T_FUNCTION_DECL);
    
    // Check function name
    ast_t* func_name = res.value.ast->child;
    TEST_ASSERT(func_name->typ == PASCAL_T_IDENTIFIER);
    TEST_ASSERT(strcmp(func_name->sym->name, "GetValue") == 0);

    free_ast(res.value.ast);    free(input->buffer);
    free(input);
}

void test_pascal_function_multiple_params(void) {
    combinator_t* p = new_combinator();
    init_pascal_procedure_parser(&p);

    input_t* input = new_input();
    input->buffer = strdup("function Calculate(a: real; b: real; c: integer): real; begin end");
    input->length = strlen(input->buffer);

    ParseResult res = parse(input, p);

    TEST_ASSERT(res.is_success);
    TEST_ASSERT(res.value.ast->typ == PASCAL_T_FUNCTION_DECL);
    
    // Check function name
    ast_t* func_name = res.value.ast->child;
    TEST_ASSERT(func_name->typ == PASCAL_T_IDENTIFIER);
    TEST_ASSERT(strcmp(func_name->sym->name, "Calculate") == 0);

    free_ast(res.value.ast);    free(input->buffer);
    free(input);
}
